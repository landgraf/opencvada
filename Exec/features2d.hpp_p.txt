
// CvAffinePose

// KeyPoint
KeyPoint();
KeyPoint(Point2f _pt, float _size, float _angle=-1,
            float _response=0, int _octave=0, int _class_id=-1);
KeyPoint(float x, float y, float _size, float _angle=-1,
            float _response=0, int _octave=0, int _class_id=-1);
static void convert(const std::vector<KeyPoint>& keypoints, std::vector<Point2f>& points2f,
                        const std::vector<int>& keypointIndexes=std::vector<int>());
static void convert(const std::vector<Point2f>& points2f, std::vector<KeyPoint>& keypoints,
                        float size=1, float response=1, int octave=0, int class_id=-1);
static float overlap(const KeyPoint& kp1, const KeyPoint& kp2);

// SIFT
SIFT();
SIFT( double _threshold, double _edgeThreshold,
          int _nOctaves=CommonParams::DEFAULT_NOCTAVES,
          int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS,
          int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE,
          int _angleMode=CommonParams::FIRST_ANGLE );
SIFT( double _magnification, bool _isNormalize=true,
          bool _recalculateAngles = true,
          int _nOctaves=CommonParams::DEFAULT_NOCTAVES,
          int _nOctaveLayers=CommonParams::DEFAULT_NOCTAVE_LAYERS,
          int _firstOctave=CommonParams::DEFAULT_FIRST_OCTAVE,
          int _angleMode=CommonParams::FIRST_ANGLE );
SIFT( const CommonParams& _commParams,
          const DetectorParams& _detectorParams = DetectorParams(),
          const DescriptorParams& _descriptorParams = DescriptorParams() );
int descriptorSize();
void operator();
void operator();
CommonParams getCommonParams ();
DetectorParams getDetectorParams ();
DescriptorParams getDescriptorParams ();

// SURF
SURF();
SURF(double _hessianThreshold, int _nOctaves=4,
         int _nOctaveLayers=2, bool _extended=false);
int descriptorSize();
void operator();
void operator();

// MSER
MSER();
MSER( int _delta, int _min_area, int _max_area,
          double _max_variation, double _min_diversity,
          int _max_evolution, double _area_threshold,
          double _min_margin, int _edge_blur_size );
void operator();

// StarDetector
StarDetector();
StarDetector(int _maxSize, int _responseThreshold,
                 int _lineThresholdProjected,
                 int _lineThresholdBinarized,
                 int _suppressNonmaxSize);
void operator();

// PatchGenerator
PatchGenerator();
PatchGenerator(double _backgroundMin, double _backgroundMax,
                   double _noiseRange, bool _randomBlur=true,
                   double _lambdaMin=0.6, double _lambdaMax=1.5,
                   double _thetaMin=-CV_PI, double _thetaMax=CV_PI,
                   double _phiMin=-CV_PI, double _phiMax=CV_PI );
void operator();
void operator();
void warpWholeImage(const Mat& image, Mat& matT, Mat& buf,
                        Mat& warped, int border, RNG& rng);
void generateRandomTransform(Point2f srcCenter, Point2f dstCenter,
                                 Mat& transform, RNG& rng, bool inverse=false);
void setAffineParam(double lambda, double theta, double phi);

// LDetector
LDetector();
LDetector(int _radius, int _threshold, int _nOctaves,
              int _nViews, double _baseFeatureSize, double _clusteringDistance);
void operator();
void operator();
void getMostStable2D(const Mat& image, vector<KeyPoint>& keypoints,
                         int maxCount, const PatchGenerator& patchGenerator);
void setVerbose(bool verbose);
void read(const FileNode& node);
void write(FileStorage& fs, const String& name=String());

// FernClassifier
FernClassifier();
FernClassifier(const FileNode& node);
FernClassifier(const vector<vector<Point2f> >& points,
                   const vector<Mat>& refimgs,
                   const vector<vector<int> >& labels=vector<vector<int> >(),
                   int _nclasses=0, int _patchSize=PATCH_SIZE,
                   int _signatureSize=DEFAULT_SIGNATURE_SIZE,
                   int _nstructs=DEFAULT_STRUCTS,
                   int _structSize=DEFAULT_STRUCT_SIZE,
                   int _nviews=DEFAULT_VIEWS,
                   int _compressionMethod=COMPRESSION_NONE,
                   const PatchGenerator& patchGenerator=PatchGenerator());
virtual ~FernClassifier();
virtual void read(const FileNode& n);
virtual void write(FileStorage& fs, const String& name=String());
virtual void trainFromSingleView(const Mat& image,
                                     const vector<KeyPoint>& keypoints,
                                     int _patchSize=PATCH_SIZE,
                                     int _signatureSize=DEFAULT_SIGNATURE_SIZE,
                                     int _nstructs=DEFAULT_STRUCTS,
                                     int _structSize=DEFAULT_STRUCT_SIZE,
                                     int _nviews=DEFAULT_VIEWS,
                                     int _compressionMethod=COMPRESSION_NONE,
                                     const PatchGenerator& patchGenerator=PatchGenerator());
virtual void train(const vector<vector<Point2f> >& points,
                       const vector<Mat>& refimgs,
                       const vector<vector<int> >& labels=vector<vector<int> >(),
                       int _nclasses=0, int _patchSize=PATCH_SIZE,
                       int _signatureSize=DEFAULT_SIGNATURE_SIZE,
                       int _nstructs=DEFAULT_STRUCTS,
                       int _structSize=DEFAULT_STRUCT_SIZE,
                       int _nviews=DEFAULT_VIEWS,
                       int _compressionMethod=COMPRESSION_NONE,
                       const PatchGenerator& patchGenerator=PatchGenerator());
virtual int operator();
virtual int operator();
virtual void clear();
void setVerbose(bool verbose);
int getClassCount();
int getStructCount();
int getStructSize();
int getSignatureSize();
int getCompressionMethod();
Size getPatchSize();
virtual void prepare(int _nclasses, int _patchSize, int _signatureSize,
                         int _nstructs, int _structSize,
                         int _nviews, int _compressionMethod);
virtual void finalize(RNG& rng);
virtual int getLeaf(int fidx, const Mat& patch);

// PlanarObjectDetector
PlanarObjectDetector();
PlanarObjectDetector(const FileNode& node);
PlanarObjectDetector(const vector<Mat>& pyr, int _npoints=300,
                         int _patchSize=FernClassifier::PATCH_SIZE,
                         int _nstructs=FernClassifier::DEFAULT_STRUCTS,
                         int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE,
                         int _nviews=FernClassifier::DEFAULT_VIEWS,
                         const LDetector& detector=LDetector(),
                         const PatchGenerator& patchGenerator=PatchGenerator());
virtual ~PlanarObjectDetector();
virtual void train(const vector<Mat>& pyr, int _npoints=300,
                       int _patchSize=FernClassifier::PATCH_SIZE,
                       int _nstructs=FernClassifier::DEFAULT_STRUCTS,
                       int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE,
                       int _nviews=FernClassifier::DEFAULT_VIEWS,
                       const LDetector& detector=LDetector(),
                       const PatchGenerator& patchGenerator=PatchGenerator());
virtual void train(const vector<Mat>& pyr, const vector<KeyPoint>& keypoints,
                       int _patchSize=FernClassifier::PATCH_SIZE,
                       int _nstructs=FernClassifier::DEFAULT_STRUCTS,
                       int _structSize=FernClassifier::DEFAULT_STRUCT_SIZE,
                       int _nviews=FernClassifier::DEFAULT_VIEWS,
                       const LDetector& detector=LDetector(),
                       const PatchGenerator& patchGenerator=PatchGenerator());
Rect getModelROI();
vector<KeyPoint> getModelPoints();
const LDetector& getDetector();
const FernClassifier& getClassifier();
void setVerbose(bool verbose);
void read(const FileNode& node);
void write(FileStorage& fs, const String& name=String());
bool operator();
bool operator();

// RandomizedTree
static float GET_LOWER_QUANT_PERC();
static float GET_UPPER_QUANT_PERC();
RandomizedTree();
~RandomizedTree();
void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,
             int depth, int views, size_t reduced_num_dim, int num_quant_bits);
void train(std::vector<BaseKeypoint> const& base_set, RNG &rng,
             PatchGenerator &make_patch, int depth, int views, size_t reduced_num_dim,
             int num_quant_bits);
static void quantizeVector(float *vec, int dim, int N, float bnds[2], int clamp_mode=0);
static void quantizeVector(float *src, int dim, int N, float bnds[2], uchar *dst);
float* getPosterior(uchar* patch_data);
const float* getPosterior(uchar* patch_data);
uchar* getPosterior2(uchar* patch_data);
const uchar* getPosterior2(uchar* patch_data);
void read(const char* file_name, int num_quant_bits);
void read(std::istream &is, int num_quant_bits);
void write(const char* file_name);
void write(std::ostream &os);
int classes();
int depth();
void discardFloatPosteriors();
inline void applyQuantization(int num_quant_bits);
void savePosteriors(std::string url, bool append=false);
void savePosteriors2(std::string url, bool append=false);
void createNodes(int num_nodes, RNG &rng);
void allocPosteriorsAligned(int num_leaves, int num_classes);
void freePosteriors(int which);
void init(int classes, int depth, RNG &rng);
void addExample(int class_id, uchar* patch_data);
void finalize(size_t reduced_num_dim, int num_quant_bits);
int getIndex(uchar* patch_data);
inline float* getPosteriorByIndex(int index);
inline const float* getPosteriorByIndex(int index);
inline uchar* getPosteriorByIndex2(int index);
inline const uchar* getPosteriorByIndex2(int index);
void convertPosteriorsToChar();
void makePosteriors2(int num_quant_bits);
void compressLeaves(size_t reduced_num_dim);
void estimateQuantPercForPosteriors(float perc[2]);

// RTreeClassifier
RTreeClassifier();
void train(std::vector<BaseKeypoint> const& base_set,
             RNG &rng,
             int num_trees = RTreeClassifier::DEFAULT_TREES,
             int depth = RandomizedTree::DEFAULT_DEPTH,
             int views = RandomizedTree::DEFAULT_VIEWS,
             size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM,
             int num_quant_bits = DEFAULT_NUM_QUANT_BITS);
void train(std::vector<BaseKeypoint> const& base_set,
             RNG &rng,
             PatchGenerator &make_patch,
             int num_trees = RTreeClassifier::DEFAULT_TREES,
             int depth = RandomizedTree::DEFAULT_DEPTH,
             int views = RandomizedTree::DEFAULT_VIEWS,
             size_t reduced_num_dim = RandomizedTree::DEFAULT_REDUCED_NUM_DIM,
             int num_quant_bits = DEFAULT_NUM_QUANT_BITS);
void getSignature(IplImage *patch, uchar *sig);
void getSignature(IplImage *patch, float *sig);
void getSparseSignature(IplImage *patch, float *sig, float thresh);
void getFloatSignature(IplImage *patch, float *sig);
static int countNonZeroElements(float *vec, int n, double tol=1e-10);
static inline void safeSignatureAlloc(uchar **sig, int num_sig=1, int sig_len=176);
static inline uchar* safeSignatureAlloc(int num_sig=1, int sig_len=176);
inline int classes();
inline int original_num_classes();
void setQuantization(int num_quant_bits);
void discardFloatPosteriors();
void read(const char* file_name);
void read(std::istream &is);
void write(const char* file_name);
void write(std::ostream &os);
void saveAllFloatPosteriors(std::string file_url);
void saveAllBytePosteriors(std::string file_url);
void setFloatPosteriorsFromTextfile_176(std::string url);
float countZeroElements();

// OneWayDescriptor
OneWayDescriptor();
~OneWayDescriptor();
void Allocate(int pose_count, CvSize size, int nChannels);
void GenerateSamples(int pose_count, IplImage* frontal, int norm = 0);
void GenerateSamplesFast(IplImage* frontal, CvMat* pca_hr_avg,
                             CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors);
void SetTransforms(CvAffinePose* poses, CvMat** transforms);
void Initialize(int pose_count, IplImage* frontal, const char* feature_name = 0, int norm = 0);
void InitializeFast(int pose_count, IplImage* frontal, const char* feature_name,
                        CvMat* pca_hr_avg, CvMat* pca_hr_eigenvectors, OneWayDescriptor* pca_descriptors);
void ProjectPCASample(IplImage* patch, CvMat* avg, CvMat* eigenvectors, CvMat* pca_coeffs);
void InitializePCACoeffs(CvMat* avg, CvMat* eigenvectors);
void EstimatePose(IplImage* patch, int& pose_idx, float& distance);
void EstimatePosePCA(CvArr* patch, int& pose_idx, float& distance, CvMat* avg, CvMat* eigenvalues);
CvSize GetPatchSize();
CvSize GetInputPatchSize();
IplImage* GetPatch(int index);
CvAffinePose GetPose(int index);
void Save(const char* path);
int ReadByName(CvFileStorage* fs, CvFileNode* parent, const char* name);
int ReadByName(const FileNode &parent, const char* name);
void Write(CvFileStorage* fs, const char* name);
const char* GetFeatureName();
CvPoint GetCenter();
void SetPCADimHigh(int pca_dim_high);
void SetPCADimLow(int pca_dim_low);
int GetPCADimLow();
int GetPCADimHigh();
CvMat** GetPCACoeffs();

// OneWayDescriptorBase
OneWayDescriptorBase(CvSize patch_size, int pose_count, const char* train_path = 0, const char* pca_config = 0,
                         const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1,
                         int pca_dim_high = 100, int pca_dim_low = 100);
OneWayDescriptorBase(CvSize patch_size, int pose_count, const string &pca_filename, const string &train_path = string(), const string &images_list = string(),
                         float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1,
                         int pca_dim_high = 100, int pca_dim_low = 100);
virtual ~OneWayDescriptorBase();
void clear ();
void Allocate(int train_feature_count);
void AllocatePCADescriptors();
CvSize GetPatchSize();
int GetPoseCount();
int GetPyrLevels();
int GetDescriptorCount();
void CreateDescriptorsFromImage(IplImage* src, const std::vector<cv::KeyPoint>& features);
void CreatePCADescriptors();
const OneWayDescriptor* GetDescriptor(int desc_idx);
void FindDescriptor(IplImage* patch, int& desc_idx, int& pose_idx, float& distance, float* _scale = 0, float* scale_ranges = 0);
void FindDescriptor(IplImage* patch, int n, std::vector<int>& desc_idxs, std::vector<int>& pose_idxs,
                        std::vector<float>& distances, std::vector<float>& _scales, float* scale_ranges = 0);
void FindDescriptor(IplImage* src, cv::Point2f pt, int& desc_idx, int& pose_idx, float& distance);
void InitializePoses();
void InitializeTransformsFromPoses();
void InitializePoseTransforms();
void InitializeDescriptor(int desc_idx, IplImage* train_image, const char* feature_label);
void InitializeDescriptor(int desc_idx, IplImage* train_image, const cv::KeyPoint& keypoint, const char* feature_label);
void InitializeDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,
                               const char* feature_label = "", int desc_start_idx = 0);
void Write (FileStorage &fs);
void Read (const FileNode &fn);
int LoadPCADescriptors(const char* filename);
int LoadPCADescriptors(const FileNode &fn);
void SavePCADescriptors(const char* filename);
void SavePCADescriptors(CvFileStorage* fs);
void GeneratePCA(const char* img_path, const char* images_list, int pose_count=500);
void SetPCAHigh(CvMat* avg, CvMat* eigenvectors);
void SetPCALow(CvMat* avg, CvMat* eigenvectors);
int GetLowPCA(CvMat** avg, CvMat** eigenvectors);
int GetPCADimLow();
int GetPCADimHigh();
void ConvertDescriptorsArrayToTree();
static string GetPCAFilename ();
void SavePCAall (FileStorage &fs);
void LoadPCAall (const FileNode &fn);

// OneWayDescriptorObject
OneWayDescriptorObject(CvSize patch_size, int pose_count, const char* train_path, const char* pca_config,
                           const char* pca_hr_config = 0, const char* pca_desc_config = 0, int pyr_levels = 1);
OneWayDescriptorObject(CvSize patch_size, int pose_count, const string &pca_filename,
                           const string &train_path = string (), const string &images_list = string (),
                           float _scale_min = 0.7f, float _scale_max=1.5f, float _scale_step=1.2f, int pyr_levels = 1);
virtual ~OneWayDescriptorObject();
void Allocate(int train_feature_count, int object_feature_count);
void SetLabeledFeatures(const vector<cv::KeyPoint>& features);
vector<cv::KeyPoint>& GetLabeledFeatures();
const vector<cv::KeyPoint>& GetLabeledFeatures();
vector<cv::KeyPoint> _GetLabeledFeatures();
int IsDescriptorObject(int desc_idx);
int MatchPointToPart(CvPoint pt);
int GetDescriptorPart(int desc_idx);
void InitializeObjectDescriptors(IplImage* train_image, const vector<cv::KeyPoint>& features,
                                     const char* feature_label, int desc_start_idx = 0, float scale = 1.0f,
                                     int is_background = 0);
int GetObjectFeatureCount();

// FeatureDetector
virtual ~FeatureDetector();
void detect( const Mat& image, vector<KeyPoint>& keypoints, const Mat& mask=Mat() );
virtual void read(const FileNode&);
virtual void write(FileStorage&);
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );
static void removeInvalidPoints( const Mat& mask, vector<KeyPoint>& keypoints );

// FastFeatureDetector
FastFeatureDetector( int _threshold = 1, bool _nonmaxSuppression = true );
virtual void read (const FileNode& fn);
virtual void write (FileStorage& fs);
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );

// GoodFeaturesToTrackDetector
GoodFeaturesToTrackDetector( int _maxCorners, double _qualityLevel, double _minDistance,
                                 int _blockSize=3, bool _useHarrisDetector=false, double _k=0.04 );
virtual void read (const FileNode& fn);
virtual void write (FileStorage& fs);
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );

// MserFeatureDetector
MserFeatureDetector( CvMSERParams params = cvMSERParams () );
MserFeatureDetector( int delta, int minArea, int maxArea, double maxVariation, double minDiversity,
                         int maxEvolution, double areaThreshold, double minMargin, int edgeBlurSize );
virtual void read (const FileNode& fn);
virtual void write (FileStorage& fs);
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );

// StarFeatureDetector
StarFeatureDetector( int maxSize=16, int responseThreshold=30, int lineThresholdProjected = 10,
                         int lineThresholdBinarized=8, int suppressNonmaxSize=5 );
virtual void read (const FileNode& fn);
virtual void write (FileStorage& fs);
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );

// SiftFeatureDetector
SiftFeatureDetector( double threshold=SIFT::DetectorParams::GET_DEFAULT_THRESHOLD(),
                         double edgeThreshold=SIFT::DetectorParams::GET_DEFAULT_EDGE_THRESHOLD(),
                         int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES,
                         int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS,
                         int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE,
                         int angleMode=SIFT::CommonParams::FIRST_ANGLE );
virtual void read (const FileNode& fn);
virtual void write (FileStorage& fs);
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );

// SurfFeatureDetector
SurfFeatureDetector( double hessianThreshold = 400., int octaves = 3, int octaveLayers = 4 );
virtual void read (const FileNode& fn);
virtual void write (FileStorage& fs);
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );

// DenseFeatureDetector
DenseFeatureDetector();
DenseFeatureDetector( float _initFeatureScale, int _featureScaleLevels=1, float _featureScaleMul=0.1f,
                          int _initXyStep=6, int _initImgBound=0, bool _varyXyStepWithScale=true, bool _varyImgBoundWithScale=false );
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );

// GridAdaptedFeatureDetector
GridAdaptedFeatureDetector( const Ptr<FeatureDetector>& _detector, int _maxTotalKeypoints,
                                int _gridRows=4, int _gridCols=4 );
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );

// PyramidAdaptedFeatureDetector
PyramidAdaptedFeatureDetector( const Ptr<FeatureDetector>& _detector, int _levels=2 );
virtual void detectImpl( const Mat& image, const Mat& mask, vector<KeyPoint>& keypoints );

// DescriptorExtractor
virtual ~DescriptorExtractor();
virtual void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors );
virtual void read( const FileNode& );
virtual void write( FileStorage& );
virtual int descriptorSize();
virtual int descriptorType();
static void removeBorderKeypoints( vector<KeyPoint>& keypoints,
                                       Size imageSize, int borderPixels );

// SiftDescriptorExtractor
SiftDescriptorExtractor( double magnification=SIFT::DescriptorParams::GET_DEFAULT_MAGNIFICATION(),
                             bool isNormalize=true, bool recalculateAngles=true,
                             int nOctaves=SIFT::CommonParams::DEFAULT_NOCTAVES,
                             int nOctaveLayers=SIFT::CommonParams::DEFAULT_NOCTAVE_LAYERS,
                             int firstOctave=SIFT::CommonParams::DEFAULT_FIRST_OCTAVE,
                             int angleMode=SIFT::CommonParams::FIRST_ANGLE );
virtual void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors );
virtual void read( const FileNode &fn );
virtual void write( FileStorage &fs );
virtual int descriptorSize();
virtual int descriptorType();

// SurfDescriptorExtractor
SurfDescriptorExtractor( int nOctaves=4,
                             int nOctaveLayers=2, bool extended=false );
virtual void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors );
virtual void read( const FileNode &fn );
virtual void write( FileStorage &fs );
virtual int descriptorSize();
virtual int descriptorType();

// CalonderDescriptorExtractor
CalonderDescriptorExtractor( const string& classifierFile );
virtual void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors );
virtual void read( const FileNode &fn );
virtual void write( FileStorage &fs );
virtual int descriptorSize();
virtual int descriptorType();

// OpponentColorDescriptorExtractor
OpponentColorDescriptorExtractor( const Ptr<DescriptorExtractor>& dextractor );
virtual void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& descriptors );
virtual void read( const FileNode& );
virtual void write( FileStorage& );
virtual int descriptorSize();
virtual int descriptorType();

// DescriptorMatcher
virtual ~DescriptorMatcher();
void add( const Mat& descriptors );
virtual void index();
void match( const Mat& query, vector<int>& matches );
void match( const Mat& query, const Mat& mask, vector<int>& matches );
void match( const Mat& query, vector<DMatch>& matches );
void match( const Mat& query, const Mat& mask, vector<DMatch>& matches );
void match( const Mat& query, const Mat& train, vector<DMatch>& matches, const Mat& mask );
void match( const Mat& query, vector<vector<DMatch> >& matches, float threshold );
void match( const Mat& query, const Mat& mask,
                vector<vector<DMatch> >&  matches, float threshold );
virtual void clear();
virtual void matchImpl( const Mat& query, const Mat& train, vector<int>& matches, const Mat& mask );
virtual void matchImpl( const Mat& query, const Mat& train, vector<DMatch>& matches, const Mat& mask );
virtual void matchImpl( const Mat& query, const Mat& train, vector<vector<DMatch> >& matches, float threshold, const Mat& mask );
static bool possibleMatch( const Mat& mask, int index_1, int index_2 );

// BruteForceMatcher
BruteForceMatcher( Distance d = Distance() );
virtual void index();
virtual void matchImpl( const Mat& query, const Mat& train, vector<int>& matches, const Mat& mask );
virtual void matchImpl( const Mat& query, const Mat& train, vector<DMatch>& matches, const Mat& mask );
virtual void matchImpl( const Mat& query, const Mat& train, vector<vector<DMatch> >& matches, float threshold, const Mat& mask );

// KeyPointCollection
void add( const Mat& _image, const vector<KeyPoint>& _points );
size_t calcKeypointCount();
KeyPoint getKeyPoint( int index );
void clear();

// GenericDescriptorMatch
GenericDescriptorMatch();
virtual ~GenericDescriptorMatch();
virtual void add( KeyPointCollection& keypoints );
virtual void add( const Mat& image, vector<KeyPoint>& points );
virtual void classify( const Mat& image, vector<KeyPoint>& points );
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<int>& indices );
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<DMatch>& matches );
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<vector<DMatch> >& matches, float threshold );
virtual void clear();
virtual void read( const FileNode& );
virtual void write( FileStorage& );

// OneWayDescriptorMatch
OneWayDescriptorMatch();
OneWayDescriptorMatch( const Params& _params );
virtual ~OneWayDescriptorMatch();
void initialize( const Params& _params, OneWayDescriptorBase *_base = 0 );
virtual void add( const Mat& image, vector<KeyPoint>& keypoints );
virtual void add( KeyPointCollection& keypoints );
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<int>& indices );
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<DMatch>& matches );
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<vector<DMatch> >& matches, float threshold);
virtual void classify( const Mat& image, vector<KeyPoint>& points );
virtual void clear ();
virtual void read( const FileNode &fn );
virtual void write( FileStorage& fs );

// FernDescriptorMatch
FernDescriptorMatch();
FernDescriptorMatch( const Params& _params );
virtual ~FernDescriptorMatch();
void initialize( const Params& _params );
virtual void add( const Mat& image, vector<KeyPoint>& keypoints );
virtual void match( const Mat& image, vector<KeyPoint>& keypoints, vector<int>& indices );
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<DMatch>& matches);
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<vector<DMatch> >& matches, float threshold);
virtual void classify( const Mat& image, vector<KeyPoint>& keypoints );
virtual void clear();
virtual void read( const FileNode &fn );
virtual void write( FileStorage& fs );
void trainFernClassifier();
void calcBestProbAndMatchIdx( const Mat& image, const Point2f& pt,
                                  float& bestProb, int& bestMatchIdx, vector<float>& signature );

// VectorDescriptorMatch
VectorDescriptorMatch( const Ptr<DescriptorExtractor>& _extractor, const Ptr<DescriptorMatcher>& _matcher );
virtual ~VectorDescriptorMatch();
void index();
virtual void add( const Mat& image, vector<KeyPoint>& keypoints );
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<int>& keypointIndices );
virtual void match( const Mat& image, vector<KeyPoint>& points, vector<DMatch>& matches );
virtual void match( const Mat& image, vector<KeyPoint>& points,
                        vector<vector<DMatch> >& matches, float threshold );
virtual void clear();
virtual void read( const FileNode& fn );
virtual void write( FileStorage& fs );

// BOWTrainer
BOWTrainer();
virtual ~BOWTrainer();
void add( const Mat& descriptors );
const vector<Mat>& getDescriptors();
int descripotorsCount();
virtual void clear();
virtual Mat cluster();
virtual Mat cluster( const Mat& descriptors );

// BOWKMeansTrainer
BOWKMeansTrainer( int clusterCount, const TermCriteria& termcrit=TermCriteria(),
                      int attempts=3, int flags=KMEANS_PP_CENTERS );
virtual ~BOWKMeansTrainer();
virtual Mat cluster();
virtual Mat cluster( const Mat& descriptors );

// BOWImgDescriptorExtractor
BOWImgDescriptorExtractor( const Ptr<DescriptorExtractor>& dextractor,
                               const Ptr<DescriptorMatcher>& dmatcher );
virtual ~BOWImgDescriptorExtractor();
void setVocabulary( const Mat& vocabulary );
const Mat& getVocabulary();
void compute( const Mat& image, vector<KeyPoint>& keypoints, Mat& imgDescriptor,
                  vector<vector<int> >* pointIdxsInClusters=0 );
int descriptorSize();
int descriptorType();
